def editDist(s1, s2, c={'change':1,'del':1,'add':1}):
#    print ">",s1,"<",">", s2,"<"
    if len(s1) <=0 and len(s2) <= 0:
        return 0

    if len(s2) == 0:
        return editDist(s1[0:-1], s2, c) + c['add']

    if len(s1) == 0:
        return editDist(s1, s2[0:-1], c) + c['del']


    if s1[-1] == s2[-1]:
        return editDist(s1[0:-1], s2[0:-1], c)

    change = editDist(s1[0:-1], s2[0:-1], c) + c['change']
    delete =  editDist(s1, s2[0:-1], c) + c['del']
    add = editDist(s1[0:-1], s2, c) + c['add']

    return min(change,delete,add)
#editDist

# arrumar forma de nao repetir sequencias como comentado no paper
def combComp(nodeList,K):
    for i in xrange(0,K+1):
        for j in xrange(1,K+1):
            if i+2*j <= len(nodeList):
                St = i
                k = i+j
                while k < len(nodeList):
                    if k+j <= len(nodeList):
                        s1 = "".join(nodeList[St:k])
                        s2 = "".join(nodeList[k:k+j])

                        print "%s %s" % (s1, s2)
                        print editDist(s1, s2)

                        St = k
                    k = k+ j
                #while
            #if
        #for
    #for
#combComp

a = ["1","1","2","1","2","1","1","2","1","1"]
print a
print combComp(a,3)


def IdentDRs(nodeList, K, T, start = 0):
    if start == len(nodeList):
        return
    print 'xxxx\n'
    maxDR = [0,0,0] #nodes in combination, start, number of nodes (start+x=end)
    for i in xrange(1,K+1):
        for j in xrange(start,len(nodeList)):
            print 'i j', i, j
            curDR= [i,j,i]
            flag = False
            if i+2*j <= len(nodeList):
                St = i
                k = i+j
                while k < len(nodeList):
                    l = curDR[0]+curDR[1]
                    if k+i <= len(nodeList):
                        print "%s %s" % (nodeList[curDR[1]:curDR[0]+curDR[1]],
                            nodeList[k:k+i])
                        s1 = "".join(
                                nodeList[curDR[1]:curDR[0]+curDR[1]])
                        s2 = "".join(nodeList[k:k+i])
                        if editDist(s1,s2) <= T:
                            print 'match'
                        #if True:
                            if not flag:
                                curDR = [i,j,k+i]
                                flag = True
                            else:
                                curDR[2] += i
                                k += i

                        elif flag:
                            break
                    k = k + i
                #while

                if maxDR[2] < curDR[2] \
                  and (maxDR[1] == 0 or curDR[1] <= maxDR[1]):
                    maxDR = curDR
                    print 'maxDR', maxDR
            #if
        #for
    #for
    if maxDR[2] >= 0 \
      and maxDR[1]+maxDR[2] <= len(nodeList):
        print 'result', maxDR
        result = []
        result.append(maxDR)
        result.append(IdentDRs(nodeList, K, T, maxDR[1]+maxDR[2]))
        return result

    return
#combComp


